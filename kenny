#!/bin/bash

if [ $# -ne 1 ]; then
	echo "$0: Usage: $0 <input.kenny>" 1>&2
	exit 1
fi

input="$1"
cache_dir="$(dirname ${input})/.cache"

# Silencing job-control messages requires some hoop-jumping.
# https://stackoverflow.com/questions/11097761/is-there-a-way-to-make-bash-job-control-quiet/38278291#38278291
set +m

mkdir -p "$cache_dir"

# FIXME: Instead of this dodgy approach, print a message and then sit and wait for the file to be created.
if [ ! -e "$input" ]; then
	echo "$0: Error: input file $input does not exist, exiting" 1>&2
	exit 1
fi

# FIXME: add a way for a single command to span multiple lines
# eg. if a line starts with whitespace, then its a continuation
# eg. require a blank line between commands

# read the commands from the input file
readarray -t commands < <(sed -e '/^#/d' -e 's/^\s*//g' -e 's/\s*$//g' -e '/^$/d' -e '/^--$/,$d' "$input")
#declare -p commands
#echo
#for cmd in "${commands[@]}"; do
#	echo "$cmd"
#done
#echo

function _cache_part_1 {
	local cache_file="$1"

	# part 1 - write input stream to cache file
	cat > "$cache_file".part &
	pid=$!
	echo $pid | tee "$cache_file".pid
	if wait %1 2>/dev/null; then
		mv -f "$cache_file".part "$cache_file"
	else
		rm -f "$cache_file".part
	fi
	rm "$cache_file".pid
}
export -f _cache_part_1

function _cache_part_2 {
	local cache_file="$1"

	# part 2 - read and output from cache file
	read pid
	tail -c +1 --follow --pid $pid "$cache_file".part
}
export -f _cache_part_2

function _make_cache_lines {
	local cache_file="$1"

	# The cached files are only valid if the pipeline runs to completion, which it might not
	# because of how less buffers its input, or if the user re-saves the input file before the pipeline
	# has finished running.  So, the cache files only become "active" once eof has been reached
	# (for that part of the pipeline).  Doing this, while ensuring that data still flows through the
	# pipeline as fast as possible, requries some hoop-jumping.

	# instead of "... | tee $cachefile | ... | less", use this:
	#
	# rm -f $cachefile $cachefile.pid; ... | ( cat > $cachefile.part & pid=$!; echo $pid | tee $cachefile.pid; if wait %1; then mv -f $cachefile.part $cachefile; else rm -f $cachefile.part; fi; rm $cachefile.pid; ) | ( read pid; tail -c +1 --follow --pid $pid $cachefile.part; ) | ... | ( less; pid="$(cat $cachefile.pid 2>/dev/null)"; if [ "$pid" ]; then kill $pid; fi; )
	#
	# with suitable adjustments to handle multiple pids/pidfiles (one for each tee part)

	pipeline_lines+=('_cache_part_1 '"'$cache_file'"' |')
	pipeline_lines+=('_cache_part_2 '"'$cache_file'"' |')

	cache_files+=("$cache_file")
	cache_pidfiles+=("$cache_file.pid")
}

function _kill_cachers {
	for cache_pidfile in "${cache_pidfiles[@]}"; do
		pid="$(cat "$cache_pidfile" 2>/dev/null)"
		if [ "$pid" ]; then
			kill $pid 2>/dev/null
			# no need to rm the pidfile here, since that will always be done by the part 1 sub-process
		fi
	done
}

cache_files=()
cache_pidfiles=()
pipeline_lines=()
use_cache=''
cmdhash=''
for cmd in "${commands[@]}"; do
	cmdhash="$(sha256sum <<<"$cmdhash $cmd" | awk '{print $1}')"
	cache_file="$cache_dir/$cmdhash"
	if [ -e "$cache_file" ]; then
		# can skip this one, and use the cached results instead
		use_cache="$cache_file"
	else
		# cannot skip, must use (plus any previous cache input)
		if [ "$use_cache" ]; then
			pipeline_lines+=("cat '$use_cache' |")
			use_cache=''
		fi
		# FIXME: wrap each pipeline stage inside `{}` (or maybe `()`),
		# so that a line like "foo; bar" will work as expected
		pipeline_lines+=("$cmd |")
		_make_cache_lines "$cache_file"
	fi
done
if [ "$use_cache" ]; then
	pipeline_lines+=("cat '$use_cache'")
else
	if [ "${#commands[@]}" -eq 0 ]; then
		pipeline_lines+=("echo '(no commands)'")
	else
		pipeline_lines+=("cat")
	fi
fi

#declare -p pipeline_lines
#echo
#for line in "${pipeline_lines[@]}"; do
#	echo "$line"
#done
#echo

pid_less=''
pid_inotifywait=''
rcfile_less="$(mktemp)"
rcfile_inotifywait="$(mktemp)"

function _cleanup {
	# exiting or reloading
	local mode="${1:-exiting}"

	local kill_pids=()

	if [ "$pid_less" ]; then
		kill_pids+=("$pid_less")
		pid_less=''
	fi
	rm -f "$rcfile_less"

	if [ "$pid_inotifywait" ]; then
		kill_pids+=("$pid_inotifywait")
		pid_inotifywait=''
	fi
	rm -f "$rcfile_inotifywait"

	if [ ${#kill_pids[@]} -gt 0 ]; then
		case "$mode" in
			reloading)
				# If we're reloading, no need to silently wait, just send the signal
				# and move on as fast as possible (so the user's updated pipeline runs
				# as soon as possible).
				kill "${kill_pids[@]}" > /dev/null 2>&1
				;;
			exiting|*)
				# If we're exiting, then wait for the pids to exit, so we can redirect
				# the job termination message to /dev/null.
				{ kill "${kill_pids[@]}" && wait; } > /dev/null 2>&1
				;;
		esac
	fi

	_kill_cachers

	stty sane
}

rm -f "${cache_files[@]}" "${cache_pidfiles[@]}"

clear
# would be nice to show some sort of progress spinner...
bash <(echo "${pipeline_lines[@]}") | (
	rm -f "$rcfile_less"
	mypid=''
	trap 'kill -9 $mypid 2>/dev/null; _kill_cachers' EXIT
	# FIXME: custom less prompt (to show where we are looking at)
	LESS= less -nLQXR &
	mypid="$!"
	wait %1 2>/dev/null
	echo "$?" > "$rcfile_less"
) &
pid_less="$!"

(
	rm -f "$rcfile_inotifywait"
	mypid=''
	trap 'kill -9 $mypid 2>/dev/null' EXIT
	inotifywait -qq -e close_write,move_self "$input" &
	mypid="$!"
	wait %1 2>/dev/null
	echo "$?" > "$rcfile_inotifywait"
) &
pid_inotifywait="$!"

trap _cleanup EXIT

wait -n 2>/dev/null

# Can't trust the rc from wait, because race conditions means if both processes have ended,
# then which one did we get the rc of?  So better to get it more directly.

rc_less="$(cat "$rcfile_less" 2>/dev/null)"
rc_inotifywait="$(cat "$rcfile_inotifywait" 2>/dev/null)"

# if both have exited, less takes priority (since it's more directly user-driven)
if [ "$rc_less" ]; then
	# less has exited, so the user wants to quit
	# FIXME: lesskey for custom ops?
	exit 0
elif [ "$rc_inotifywait" ]; then
	# inotify ended
	if [ "$rc_inotifywait" -eq 0 ]; then
		# actual change
		# fall through to loop
		:
	else
		# failure
		echo "$0: Error: inotifywait failure, exiting" 1>&2
		exit "$rc_inotifywait"
	fi
else
	# wait says that one has exited, but it hasn't recorded its rc in its file - strange, and shouldn't happen
	echo "$0: Error: couldn't get rc of less or inotifywait, exiting" 1>&2
	exit 1
fi

# 'exec' isn't exiting, so the trap doesn't fire, so call it manually
_cleanup reloading
exec "$0" "$@"
