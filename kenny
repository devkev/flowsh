#!/bin/bash

if [ $# -ne 1 ]; then
	echo "$0: Usage: $0 <input.kenny>" 1>&2
	exit 1
fi

input="$1"
cachedir="$(dirname ${input})/.cache"

mkdir -p "$cachedir"

# FIXME: Instead of this dodgy approach, print a message and then sit and wait for the file to be created.
if [ ! -e "$input" ]; then
	echo "$0: Error: input file $input does not exist, exiting" 1>&2
	exit 1
fi

# read the commands from the input file
readarray -t commands < <(sed -e '/^#/d' -e 's/^\s*//g' -e 's/\s*$//g' -e '/^$/d' -e '/^--$/,$d' "$input")
#declare -p commands
#echo
#for cmd in "${commands[@]}"; do
#	echo "$cmd"
#done
#echo

# FIXME: the cached files are only valid if the pipeline runs to completion, which it might not
# because of how less buffers its input, or if the user re-saves the input file before the pipeline
# has finished running.  so, the cache files should only become "active" once eof has been reached
# (for that part of the pipeline).

# instead of "... | tee $cachefile | ... | less", use this:
#
# rm -f $cachefile $cachefile.pid; ... | ( cat > $cachefile.part & pid=$!; echo $pid | tee $cachefile.pid; if wait %1; then mv -f $cachefile.part $cachefile; else rm -f $cachefile.part; fi; rm $cachefile.pid; ) | ( read pid; tail -c +1 --follow --pid $pid $cachefile.part; ) | ... | ( less; pid="$(cat $cachefile.pid 2>/dev/null)"; if [ "$pid" ]; then kill $pid; fi; )
#
# with suitable adjustments to handle multiple pids/pidfiles for each tee part

pipeline_lines=()
use_cache=''
cmdhash=''
for cmd in "${commands[@]}"; do
	cmdhash="$(sha256sum <<<"$cmdhash $cmd" | awk '{print $1}')"
	if [ -e "$cachedir/$cmdhash" ]; then
		# can skip this one, and use the cached results instead
		use_cache="$cachedir/$cmdhash"
	else
		# cannot skip, must use (plus any previous cache input)
		if [ "$use_cache" ]; then
			pipeline_lines+=("cat '$use_cache' |")
			use_cache=''
		fi
		pipeline_lines+=("$cmd |")
		pipeline_lines+=("tee '$cachedir/$cmdhash' |")
	fi
done
if [ "$use_cache" ]; then
	pipeline_lines+=("cat '$use_cache'")
else
	if [ "${#commands[@]}" -eq 0 ]; then
		pipeline_lines+=("echo '(no commands)'")
	else
		pipeline_lines+=("cat")
	fi
fi

#declare -p pipeline_lines
#echo
#for line in "${pipeline_lines[@]}"; do
#	echo "$line"
#done
#echo

pid_less=''
pid_inotifywait=''
rcfile_less="$(mktemp)"
rcfile_inotifywait="$(mktemp)"

function cleanup {
	if [ "$pid_less" ]; then
		kill "$pid_less" > /dev/null 2>&1
		pid_less=''
	fi
	rm -f "$rcfile_less"

	if [ "$pid_inotifywait" ]; then
		kill "$pid_inotifywait" > /dev/null 2>&1
		pid_inotifywait=''
	fi
	rm -f "$rcfile_inotifywait"
	stty sane
}

clear
# would be nice to show some sort of progress spinner...
bash <(echo "${pipeline_lines[@]}") | (
	rm -f "$rcfile_less"
	mypid=''
	trap 'kill -9 $mypid 2>/dev/null' EXIT
	# FIXME: custom less prompt (to show where we are looking at)
	LESS= less -nLQXR &
	mypid="$!"
	wait
	echo "$?" > "$rcfile_less"
) &
pid_less="$!"

(
	rm -f "$rcfile_inotifywait"
	mypid=''
	trap 'kill -9 $mypid 2>/dev/null' EXIT
	inotifywait -qq -e close_write,move_self "$input" &
	mypid="$!"
	wait
	echo "$?" > "$rcfile_inotifywait"
) &
pid_inotifywait="$!"

trap cleanup EXIT

wait -n

# Can't trust the rc from wait, because race conditions means if both processes have ended,
# then which one did we get the rc of?  So better to get it more directly.

rc_less="$(cat "$rcfile_less" 2>/dev/null)"
rc_inotifywait="$(cat "$rcfile_inotifywait" 2>/dev/null)"

# if both have exited, less takes priority (since it's more directly user-driven)
if [ "$rc_less" ]; then
	# less has exited, so the user wants to quit
	# FIXME: lesskey for custom ops?
	exit 0
elif [ "$rc_inotifywait" ]; then
	# inotify ended
	if [ "$rc_inotifywait" -eq 0 ]; then
		# actual change
		# fall through to loop
		:
	else
		# failure
		echo "$0: Error: inotifywait failure, exiting" 1>&2
		exit "$rc_inotifywait"
	fi
else
	# wait says that one has exited, but it hasn't recorded its rc in its file - strange, and shouldn't happen
	echo "$0: Error: couldn't get rc of less or inotifywait, exiting" 1>&2
	exit 1
fi

# 'exec' isn't exiting, so the trap doesn't fire, so call it manually
cleanup
exec "$0" "$@"
